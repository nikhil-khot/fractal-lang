#lang racket

(require 2htdp/universe)
;(require 2htdp/image)
(require racket/draw)

(define WIDTH 500)
(define HEIGHT 500)
(define MAX-ITER 100)
(define ZOOM 100.0)

;;Represents the state of the rendering of the escape time fractal
(define-struct world-state [image max-iterations zoom])

;;The updater for a Mandelbrot fractal
(define mand-upd (λ (z c) (+ (* z z) c)))

;;The updater for a Burning Ship fractal
(define burn-upd (λ (z c)
                   (+
                    (* (make-rectangular (abs (real-part z)) (abs (imag-part z))) 
                       (make-rectangular (abs (real-part z)) (abs (imag-part z)))) 
                    c)))

;;The updater for a Julia fractal
(define julia-upd (λ (k) (λ (z _) (+ (* z z) k))))


;;Finds the number of steps it takes to escape to infinity given some updater
(define (steps-to-inf et-fractal-update x y world)
  (letrec
      ([complex-posn (make-rectangular (/ (- x
                                             (/ (send (world-state-image world) get-width)
                                                2))
                                          (world-state-zoom world))
                                       (/ (- y (/
                                                (send (world-state-image world) get-height)
                                                2))
                                          (world-state-zoom world)))]
       [stepper (λ (z iteration)
                  (if (or (>= iteration (world-state-max-iterations world))
                          (> (magnitude z) 2))
                      iteration
                      (stepper (et-fractal-update z complex-posn) (add1 iteration))))])
    (stepper 0+0i 0)))

; Maps iteration count to color
(define (simple-color world)
  (λ (steps)
    (if (= steps (world-state-max-iterations world))
        (make-color 0 0 0)
        (make-color (min 255 (* 10 steps)) ;; 2/6
                    (min 255 (* 5 steps))  ;; 1/6
                    (min 255 (* 15 steps))))));3/6

;;Curried: returns a func that will take in the number of steps
(define (simple-color-ratio r-ratio g-ratio b-ratio world)
  (if (> (+ r-ratio b-ratio g-ratio) 1)
      (error "The given ratios of red green and blue values is greater than 1!"
             r-ratio g-ratio b-ratio)
      (λ (steps)
        (let
            ([red (* steps (/ r-ratio 1/255))]
             [green (* steps (/ g-ratio 1/255))]
             [blue (* steps (/ b-ratio 1/255))])
          (if (= steps (world-state-max-iterations world))
              (make-color 0 0 0)
              (make-color (min 255 (ceiling red))
                          (min 255 (ceiling green))
                          (min 255 (ceiling blue))))))))
(define beside (λ (a b) a))
(define above (λ (a b) a))


; Generates the image of the given fractal
#;(define (draw-fractal etf-updater color-func world)
    (apply beside
           (for/list ([x (in-range (send (world-state-image world) get-width))])
             (displayln x)
             (apply above
                    (for/list ([y (in-range (send (world-state-image world) get-height))])
                      y
                      #;(rectangle 1 1 "solid"
                                   (color-func (steps-to-inf etf-updater x y world))))))))
; Generates the image of the given fractal
;;This could be faster if we went backwards through the inage so we dont need to append
(define (draw-fractal-mutates etf-updater color-func world)
  (letrec
      ([create-bytes (λ (x y prev-bytes)
                       (let* ([steps (steps-to-inf etf-updater x y world)]
                              [color (color-func steps)]
                              [image (world-state-image world)]
                              [next-x (if (= x (sub1 (send (world-state-image world) get-width)))
                                          0
                                          (add1 x))]
                              [next-y (if (= y (sub1 (send (world-state-image world) get-height)))
                                          0
                                          (add1 y))]
                              [curr-bytes (bytes 0
                                                 (send color red)
                                                 (send color green)
                                                 (send color blue))])
                        
                         (if (and (= next-x 0) (= next-y 0))
                             (bytes-append curr-bytes prev-bytes)
                             (create-bytes next-x next-y (bytes-append curr-bytes prev-bytes))
                             )))]
       [image (world-state-image world)])
    (begin
      (displayln (bytes-length (create-bytes 0 0 (bytes))))
      (displayln (* (send (world-state-image world) get-width)
                    (send (world-state-image world) get-height)
                    4))
      (send image set-argb-pixels 0 0	 	 	 
          (send (world-state-image world) get-width)
          (send (world-state-image world) get-height)
          (create-bytes 0 0 (bytes))
          image)
           image)))


#; (for/list ([x (in-range (send (world-state-image world) get-width))])
     (for/list ([y (in-range (send (world-state-image world) get-height))])
       (let* ([steps (steps-to-inf etf-updater x y world)]
              [color (color-func steps)]
              [image (world-state-image world)])
         (begin (send image set-argb-pixels x y 	 	 	 
                      1
                      1
                      (bytes 0 (send color red)
                             (send color green)
                             (send color blue))
                      image)))))

; Draw function for big-bang
(define (render world)
  (draw-fractal-mutates burn-upd
                        (simple-color world)
                        world))

(define (key-handeler worldstate key)
  (cond
    [(string=? key "=")
     (make-world-state (send (world-state-image worldstate) get-width) 
                       (send (world-state-image worldstate) get-height)
                       (world-state-max-iterations worldstate)
                       (+ 50 (world-state-zoom worldstate)))]
    [(string=? key "-")
     (make-world-state (send (world-state-image worldstate) get-width) 
                       (send (world-state-image worldstate) get-height)
                       (world-state-max-iterations worldstate)
                       (max 100 (- 50 (world-state-zoom worldstate))))]
    [else worldstate]))

(render (make-world-state
         (make-object bitmap% WIDTH HEIGHT)
         MAX-ITER
         ZOOM))

; Start the big-bang simulation
#;(define (BANG)
    (big-bang (make-world-state
               (make-object bitmap% WIDTH HEIGHT)
               MAX-ITER
               ZOOM)
      (on-draw render)
      (on-key key-handeler)))



;;(BANG)


